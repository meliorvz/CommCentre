# T-002: Create Row-Level Security Policies

| Field | Value |
|-------|-------|
| **Status** | ðŸŸ¡ READY |
| **Round** | 1 (No Dependencies) |
| **Effort** | 4-6 hours |
| **Assignee** | _____________ |

---

## Background

**Row-Level Security (RLS)** is a PostgreSQL feature that automatically filters rows based on session variables. Even if application code has a bug and forgets a WHERE clause, RLS ensures data can't leak between tenants.

One security reviewer noted: *"Filtering in code is necessary but not sufficient. With 50 businesses, one missed WHERE clause becomes a breach."*

This is **defense-in-depth**: we do explicit filtering in code AND have RLS as a safety net at the database level.

---

## Current State (Problem)

- No RLS policies exist on any tables
- Tenant isolation relies entirely on application-level WHERE clauses
- A bug in any API route could expose data across companies
- The `properties`, `stays`, `threads`, and `messages` tables already exist but have no row-level protection

---

## What This Ticket Achieves

Enable RLS on all tenant-scoped tables with policies that check the `app.company_id` session variable. This means:

1. Every query automatically filters by the current company
2. Even raw SQL queries can't access other tenants' data
3. Super admins can bypass RLS when needed for platform operations

---

## Files to Create

### `src/db/migrations/0031_row_level_security.sql`

```sql
-- ============================================
-- ENABLE ROW LEVEL SECURITY ON ALL TABLES
-- ============================================

-- New tables from T-001
ALTER TABLE company_profile ENABLE ROW LEVEL SECURITY;
ALTER TABLE company_ai_config ENABLE ROW LEVEL SECURITY;
ALTER TABLE company_prompts ENABLE ROW LEVEL SECURITY;
ALTER TABLE knowledge_categories ENABLE ROW LEVEL SECURITY;
ALTER TABLE knowledge_items ENABLE ROW LEVEL SECURITY;
ALTER TABLE company_templates ENABLE ROW LEVEL SECURITY;
ALTER TABLE property_settings ENABLE ROW LEVEL SECURITY;
ALTER TABLE comms_events ENABLE ROW LEVEL SECURITY;

-- Existing tables
ALTER TABLE properties ENABLE ROW LEVEL SECURITY;
ALTER TABLE stays ENABLE ROW LEVEL SECURITY;
ALTER TABLE threads ENABLE ROW LEVEL SECURITY;
ALTER TABLE messages ENABLE ROW LEVEL SECURITY;

-- ============================================
-- TENANT ISOLATION POLICIES
-- ============================================

-- Tables with direct company_id column
CREATE POLICY tenant_isolation ON company_profile
    FOR ALL USING (company_id = current_setting('app.company_id', true)::uuid);

CREATE POLICY tenant_isolation ON company_ai_config
    FOR ALL USING (company_id = current_setting('app.company_id', true)::uuid);

CREATE POLICY tenant_isolation ON company_prompts
    FOR ALL USING (company_id = current_setting('app.company_id', true)::uuid);

CREATE POLICY tenant_isolation ON knowledge_categories
    FOR ALL USING (company_id = current_setting('app.company_id', true)::uuid);

CREATE POLICY tenant_isolation ON knowledge_items
    FOR ALL USING (company_id = current_setting('app.company_id', true)::uuid);

CREATE POLICY tenant_isolation ON company_templates
    FOR ALL USING (company_id = current_setting('app.company_id', true)::uuid);

CREATE POLICY tenant_isolation ON property_settings
    FOR ALL USING (company_id = current_setting('app.company_id', true)::uuid);

CREATE POLICY tenant_isolation ON properties
    FOR ALL USING (company_id = current_setting('app.company_id', true)::uuid);

CREATE POLICY tenant_isolation ON comms_events
    FOR ALL USING (company_id = current_setting('app.company_id', true)::uuid);

-- Tables with indirect company reference (through properties)
CREATE POLICY tenant_isolation ON stays
    FOR ALL USING (
        property_id IN (
            SELECT id FROM properties 
            WHERE company_id = current_setting('app.company_id', true)::uuid
        )
    );

CREATE POLICY tenant_isolation ON threads
    FOR ALL USING (
        stay_id IN (
            SELECT s.id FROM stays s
            JOIN properties p ON s.property_id = p.id
            WHERE p.company_id = current_setting('app.company_id', true)::uuid
        )
    );

CREATE POLICY tenant_isolation ON messages
    FOR ALL USING (
        thread_id IN (
            SELECT t.id FROM threads t
            JOIN stays s ON t.stay_id = s.id
            JOIN properties p ON s.property_id = p.id
            WHERE p.company_id = current_setting('app.company_id', true)::uuid
        )
    );

-- ============================================
-- SUPER ADMIN BYPASS POLICIES
-- ============================================

CREATE POLICY super_admin_bypass ON company_profile
    FOR ALL USING (current_setting('app.is_super_admin', true)::boolean = true);

CREATE POLICY super_admin_bypass ON company_ai_config
    FOR ALL USING (current_setting('app.is_super_admin', true)::boolean = true);

CREATE POLICY super_admin_bypass ON company_prompts
    FOR ALL USING (current_setting('app.is_super_admin', true)::boolean = true);

CREATE POLICY super_admin_bypass ON knowledge_categories
    FOR ALL USING (current_setting('app.is_super_admin', true)::boolean = true);

CREATE POLICY super_admin_bypass ON knowledge_items
    FOR ALL USING (current_setting('app.is_super_admin', true)::boolean = true);

CREATE POLICY super_admin_bypass ON company_templates
    FOR ALL USING (current_setting('app.is_super_admin', true)::boolean = true);

CREATE POLICY super_admin_bypass ON property_settings
    FOR ALL USING (current_setting('app.is_super_admin', true)::boolean = true);

CREATE POLICY super_admin_bypass ON properties
    FOR ALL USING (current_setting('app.is_super_admin', true)::boolean = true);

CREATE POLICY super_admin_bypass ON comms_events
    FOR ALL USING (current_setting('app.is_super_admin', true)::boolean = true);

CREATE POLICY super_admin_bypass ON stays
    FOR ALL USING (current_setting('app.is_super_admin', true)::boolean = true);

CREATE POLICY super_admin_bypass ON threads
    FOR ALL USING (current_setting('app.is_super_admin', true)::boolean = true);

CREATE POLICY super_admin_bypass ON messages
    FOR ALL USING (current_setting('app.is_super_admin', true)::boolean = true);
```

---

## Important Notes

1. **`current_setting('app.company_id', true)`** - The `true` parameter means "return NULL if not set" rather than throwing an error. This is safer.

2. **FOR ALL** - Applies to SELECT, INSERT, UPDATE, DELETE. You can be more granular if needed.

3. **Subqueries for stays/threads/messages** - These don't have direct `company_id`, so we join through the ownership chain.

4. **This migration depends on T-001** - The new tables must exist before we can add policies. However, you can write and test this SQL in parallel, then run it after T-001 merges.

---

## Acceptance Criteria

- [ ] RLS enabled on all 12 tables listed above
- [ ] `tenant_isolation` policy exists on each table
- [ ] `super_admin_bypass` policy exists on each table
- [ ] Migration runs without errors
- [ ] **Test**: Query without setting `app.company_id` returns 0 rows
- [ ] **Test**: Query with `app.company_id` set returns only that company's rows

---

## How to Test

```sql
-- Connect to the database and test WITHOUT setting company_id
SELECT * FROM company_profile;  
-- Should return 0 rows (RLS blocks everything)

-- Set company_id for this session
SET LOCAL app.company_id = 'xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx';
SELECT * FROM company_profile;  
-- Should return only that company's profile

-- Test super admin bypass
SET LOCAL app.is_super_admin = 'true';
SELECT * FROM company_profile;  
-- Should return ALL companies' profiles
```

---

## Definition of Done

- [ ] Code reviewed
- [ ] Migration tested on dev database  
- [ ] Test cases documented and passing
- [ ] PR merged to main
