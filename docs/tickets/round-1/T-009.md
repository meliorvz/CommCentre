# T-009: Implement Email Webhook Validation

| Field | Value |
|-------|-------|
| **Status** | ðŸŸ¡ READY |
| **Round** | 1 (No Dependencies) |
| **Effort** | 2-3 hours |
| **Assignee** | _____________ |

---

## Background

This platform receives **inbound emails via Cloudflare Email Routing**. When an email arrives at the platform's domain (e.g., `inbox@paradisecomms.au`), Cloudflare forwards it to a Worker endpoint.

Currently, **the email webhook has no authentication**. While Cloudflare's Email Routing is relatively secure (only Cloudflare can call the Worker's email handler), there's also an HTTP webhook fallback that has no protection.

---

## Current State (Problem)

```typescript
// src/worker/email-handler.ts

// Email routing handler - gets called by Cloudflare
export default {
    async email(message: ForwardableEmailMessage, env: Env) {
        // Process inbound email...
    }
}

// src/worker/routes/webhooks/email.ts
// HTTP fallback - NO AUTHENTICATION!
app.post('/api/webhooks/email/inbound', async (c) => {
    // Anyone can POST fake emails here
});
```

---

## What This Ticket Achieves

Add authentication to the HTTP email webhook endpoint. Choose one of the following approaches:

1. **Secret token in URL** (simplest): `/api/webhooks/email/inbound/{secret}`
2. **HMAC signature on payload** (most secure)
3. **IP allowlist** (if using a specific email provider)

---

## Recommended Implementation: Secret Token

### `src/worker/routes/webhooks/email.ts`

```typescript
// Add secret token to the route path
app.post('/api/webhooks/email/inbound/:token', async (c) => {
    const token = c.req.param('token');
    
    // Validate against environment secret
    if (token !== c.env.EMAIL_WEBHOOK_SECRET) {
        console.warn('Invalid email webhook token');
        return c.text('Forbidden', 403);
    }
    
    // Process the email...
    const body = await c.req.json();
    // ...
});
```

### Environment Variable

Add to `wrangler.toml` secrets:

```bash
npx wrangler secret put EMAIL_WEBHOOK_SECRET
# Enter a random 32+ character string
```

---

## Alternative: HMAC Signature (More Secure)

If you control the email forwarding service, you can have it sign payloads:

```typescript
import { createHmac, timingSafeEqual } from 'crypto';

function validateEmailSignature(
    secret: string,
    signature: string,
    payload: string
): boolean {
    const expected = createHmac('sha256', secret)
        .update(payload)
        .digest('hex');
    
    return timingSafeEqual(
        Buffer.from(signature),
        Buffer.from(expected)
    );
}

app.post('/api/webhooks/email/inbound', async (c) => {
    const signature = c.req.header('X-Email-Signature');
    const body = await c.req.text();
    
    if (!validateEmailSignature(c.env.EMAIL_WEBHOOK_SECRET, signature || '', body)) {
        return c.text('Forbidden', 403);
    }
    
    const payload = JSON.parse(body);
    // Process email...
});
```

---

## Acceptance Criteria

- [ ] HTTP email webhook has authentication mechanism
- [ ] Invalid/missing auth returns 403 Forbidden
- [ ] Cloudflare Email Routing (native `email()` handler) still works
- [ ] Environment secret configured in wrangler.toml
- [ ] Tested with valid and invalid requests

---

## How to Test

```bash
# Test without token - should fail
curl -X POST https://your-worker.workers.dev/api/webhooks/email/inbound \
  -H "Content-Type: application/json" \
  -d '{"from":"test@example.com","to":"inbox@paradisecomms.au"}'
# Expected: 403 Forbidden

# Test with valid token - should succeed
curl -X POST https://your-worker.workers.dev/api/webhooks/email/inbound/YOUR_SECRET_TOKEN \
  -H "Content-Type: application/json" \
  -d '{"from":"test@example.com","to":"inbox@paradisecomms.au"}'
# Expected: 200 OK
```

---

## Definition of Done

- [ ] Code reviewed
- [ ] Secret configured in development and production
- [ ] Invalid request test (403)
- [ ] Valid request test (200)
- [ ] PR merged to main
