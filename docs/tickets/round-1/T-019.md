# T-019: Add CSRF Protection

| Field | Value |
|-------|-------|
| **Status** | üü° READY |
| **Round** | 1 (No Dependencies) |
| **Effort** | 4-6 hours |
| **Assignee** | _____________ |

---

## Background

**Cross-Site Request Forgery (CSRF)** is an attack where a malicious website tricks a logged-in user's browser into making requests to our platform. If the user is logged in with a session cookie, the browser automatically includes it, and the action executes.

Example attack:
1. Admin is logged into Paradise Comms
2. Admin visits a malicious site
3. Malicious site has hidden form: `<form action="https://paradisecomms.au/api/settings" method="POST">`
4. Browser sends the request WITH the admin's cookies
5. Settings are changed without the admin's knowledge

---

## Current State (Problem)

The platform uses **cookie-based authentication** with `SameSite=None`:

```typescript
// src/worker/routes/auth.ts
c.cookie('auth_token', token, {
    httpOnly: true,
    secure: true,
    sameSite: 'None', // ‚Üê Allows cross-origin requests!
    maxAge: 60 * 60 * 24 * 7,
});
```

State-changing routes (POST, PUT, DELETE) have no CSRF protection.

---

## What This Ticket Achieves

Implement CSRF protection using one (or both) of these approaches:

1. **Change to Bearer token auth** (recommended for APIs)
2. **Double-submit cookie pattern** (if keeping cookie auth)
3. **SameSite=Lax cookies** (simplest, some browser compat concerns)

---

## Option 1: Bearer Token Auth (Recommended)

If the frontend stores the JWT in memory/localStorage and sends it via `Authorization: Bearer xxx`, CSRF is not possible because:
- JavaScript from other origins can't read the token
- Cookies aren't automatically sent

### Implementation

**Backend: `src/worker/middleware/auth.ts`**

```typescript
export async function authMiddleware(c: Context, next: Next) {
    // Check Authorization header first
    const authHeader = c.req.header('Authorization');
    
    if (authHeader?.startsWith('Bearer ')) {
        const token = authHeader.slice(7);
        try {
            const payload = await verifyJwt(token, c.env.JWT_SECRET);
            c.set('user', payload);
            c.set('companyId', payload.companyId);
            return next();
        } catch {
            return c.json({ error: 'Invalid token' }, 401);
        }
    }
    
    // Fallback to cookie (for backward compatibility)
    const cookieToken = getCookie(c, 'auth_token');
    if (cookieToken) {
        // CSRF check required for cookie auth
        const csrfHeader = c.req.header('X-CSRF-Token');
        const csrfCookie = getCookie(c, 'csrf_token');
        
        if (!csrfHeader || csrfHeader !== csrfCookie) {
            return c.json({ error: 'CSRF validation failed' }, 403);
        }
        
        // ... verify JWT from cookie
    }
    
    return c.json({ error: 'Authentication required' }, 401);
}
```

**Frontend changes:**
```typescript
// Store token in memory after login
let authToken = null;

async function login(email, password) {
    const res = await fetch('/api/auth/login', { method: 'POST', body: ... });
    const { token } = await res.json();
    authToken = token;
}

// Include in all requests
async function apiRequest(url, options = {}) {
    return fetch(url, {
        ...options,
        headers: {
            ...options.headers,
            'Authorization': `Bearer ${authToken}`,
        },
    });
}
```

---

## Option 2: Double-Submit Cookie Pattern

If you need to keep cookie auth, implement double-submit:

1. Server sets a CSRF token in a cookie (readable by JS)
2. Client reads cookie and sends same value in header
3. Server verifies they match

### Implementation

**Login response:**

```typescript
app.post('/api/auth/login', async (c) => {
    // ... verify credentials
    
    const csrfToken = crypto.randomUUID();
    
    // Set auth cookie (httpOnly)
    setCookie(c, 'auth_token', jwt, { httpOnly: true, sameSite: 'Lax' });
    
    // Set CSRF cookie (readable by JS)
    setCookie(c, 'csrf_token', csrfToken, { httpOnly: false, sameSite: 'Lax' });
    
    return c.json({ success: true });
});
```

**Middleware:**

```typescript
export async function csrfMiddleware(c: Context, next: Next) {
    // Skip for GET/HEAD/OPTIONS
    if (['GET', 'HEAD', 'OPTIONS'].includes(c.req.method)) {
        return next();
    }
    
    const csrfHeader = c.req.header('X-CSRF-Token');
    const csrfCookie = getCookie(c, 'csrf_token');
    
    if (!csrfHeader || !csrfCookie || csrfHeader !== csrfCookie) {
        return c.json({ error: 'CSRF validation failed' }, 403);
    }
    
    return next();
}
```

**Frontend:**

```typescript
function getCsrfToken() {
    return document.cookie
        .split('; ')
        .find(row => row.startsWith('csrf_token='))
        ?.split('=')[1];
}

async function apiRequest(url, options = {}) {
    return fetch(url, {
        ...options,
        headers: {
            ...options.headers,
            'X-CSRF-Token': getCsrfToken(),
        },
    });
}
```

---

## Option 3: SameSite=Lax (Simplest)

Just change the cookie SameSite attribute:

```typescript
setCookie(c, 'auth_token', jwt, {
    httpOnly: true,
    secure: true,
    sameSite: 'Lax', // ‚Üê Changed from 'None'
});
```

With `SameSite=Lax`:
- Cookies are sent on same-site navigation (clicking links)
- Cookies are NOT sent on cross-origin POST requests
- CSRF attacks via form submission are blocked

**Caveat**: May break if your frontend and API are on different domains.

---

## Acceptance Criteria

- [ ] Choose implementation approach (Bearer/Double-submit/SameSite)
- [ ] State-changing routes protected from CSRF
- [ ] Cross-origin POST without proper auth returns 403
- [ ] Same-origin requests with proper auth work
- [ ] Frontend updated if needed

---

## How to Test

```bash
# Test CSRF protection - should fail
curl -X POST https://paradisecomms.au/api/settings \
  -H "Cookie: auth_token=valid-token" \
  -d '{"assistantName":"Hacked"}'
# Expected: 403 Forbidden

# Test with proper CSRF token - should succeed
curl -X POST https://paradisecomms.au/api/settings \
  -H "Cookie: auth_token=valid-token; csrf_token=xxx" \
  -H "X-CSRF-Token: xxx" \
  -d '{"assistantName":"Mark"}'
# Expected: 200 OK
```

---

## Definition of Done

- [ ] Code reviewed
- [ ] CSRF protection implemented
- [ ] Frontend updated (if needed)
- [ ] Cross-origin attack test fails
- [ ] Normal usage test passes
- [ ] PR merged to main
