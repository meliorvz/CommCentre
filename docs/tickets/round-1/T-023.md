# T-023: Create Per-Tenant Integration Token Storage

| Field | Value |
|-------|-------|
| **Status** | ðŸŸ¡ READY |
| **Round** | 1 (No Dependencies) |
| **Effort** | 6-8 hours |
| **Assignee** | _____________ |

---

## Background

This platform integrates with third-party services (Gmail, Twilio, Telegram) using API tokens. Currently, these tokens are stored either:

1. **In environment variables** (global, shared by all companies)
2. **In the companies table** (unencrypted, visible to admins)

Both approaches have serious security issues:
- **Global tokens**: All companies share the same Gmail account!
- **Unencrypted storage**: Token theft exposes customer accounts

---

## Current State (Problem)

```typescript
// Global Twilio - ALL companies use the same account!
const twilioClient = twilio(env.TWILIO_ACCOUNT_SID, env.TWILIO_AUTH_TOKEN);

// Gmail tokens stored unencrypted in companies table
const company = await db.select().from(companies).where(...);
const refreshToken = company.gmailRefreshToken; // Plain text!
```

---

## What This Ticket Achieves

Create a secure `company_integrations` table with:

1. **Per-company tokens** - Each company has their own integrations
2. **Envelope encryption** - Tokens encrypted with a data key, data key encrypted with master key
3. **Audit logging** - Track when tokens are accessed

---

## Database Tables

```sql
-- Per-company integration credentials
CREATE TABLE company_integrations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    company_id UUID NOT NULL REFERENCES companies(id) ON DELETE CASCADE,
    integration_type TEXT NOT NULL CHECK (integration_type IN ('gmail', 'twilio', 'telegram')),
    
    -- Encrypted credentials (envelope encryption)
    encrypted_credentials BYTEA NOT NULL,
    data_key_encrypted BYTEA NOT NULL, -- Data key encrypted with master key
    
    -- Account identifier (not sensitive)
    account_identifier TEXT, -- e.g., email address, phone number
    
    -- Status
    is_active BOOLEAN NOT NULL DEFAULT true,
    last_used_at TIMESTAMPTZ,
    last_error TEXT,
    
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    UNIQUE(company_id, integration_type)
);

-- Audit log for token access
CREATE TABLE integration_token_access_log (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    company_id UUID NOT NULL REFERENCES companies(id) ON DELETE CASCADE,
    integration_type TEXT NOT NULL,
    action TEXT NOT NULL CHECK (action IN ('read', 'write', 'delete')),
    actor_user_id UUID REFERENCES users(id),
    actor_ip TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_integration_access_log ON integration_token_access_log(company_id, created_at DESC);
```

---

## Encryption Implementation

### Envelope Encryption

We use **envelope encryption** where:
1. Generate a random **data encryption key (DEK)** for each integration
2. Encrypt the credentials with the DEK (AES-256-GCM)
3. Encrypt the DEK with the **master key** (from environment)
4. Store both encrypted values in the database

This way:
- Master key rotation only requires re-encrypting DEKs, not all credentials
- Each integration has a unique key

### Implementation

**`src/worker/lib/encryption.ts`**

```typescript
export interface EncryptedData {
    encryptedCredentials: Uint8Array;
    encryptedDataKey: Uint8Array;
}

/**
 * Encrypt credentials using envelope encryption
 */
export async function encryptCredentials(
    masterKey: string,
    credentials: string
): Promise<EncryptedData> {
    // Generate random data encryption key (32 bytes for AES-256)
    const dataKey = crypto.getRandomValues(new Uint8Array(32));
    
    // Import keys
    const masterCryptoKey = await crypto.subtle.importKey(
        'raw',
        new TextEncoder().encode(masterKey).slice(0, 32),
        'AES-GCM',
        false,
        ['encrypt']
    );
    
    const dataCryptoKey = await crypto.subtle.importKey(
        'raw',
        dataKey,
        'AES-GCM',
        false,
        ['encrypt']
    );
    
    // Generate IVs
    const credentialsIv = crypto.getRandomValues(new Uint8Array(12));
    const dataKeyIv = crypto.getRandomValues(new Uint8Array(12));
    
    // Encrypt credentials with data key
    const encryptedCreds = await crypto.subtle.encrypt(
        { name: 'AES-GCM', iv: credentialsIv },
        dataCryptoKey,
        new TextEncoder().encode(credentials)
    );
    
    // Encrypt data key with master key
    const encryptedDek = await crypto.subtle.encrypt(
        { name: 'AES-GCM', iv: dataKeyIv },
        masterCryptoKey,
        dataKey
    );
    
    // Combine IV + ciphertext for each
    return {
        encryptedCredentials: concatArrays(credentialsIv, new Uint8Array(encryptedCreds)),
        encryptedDataKey: concatArrays(dataKeyIv, new Uint8Array(encryptedDek)),
    };
}

/**
 * Decrypt credentials
 */
export async function decryptCredentials(
    masterKey: string,
    encryptedCredentials: Uint8Array,
    encryptedDataKey: Uint8Array
): Promise<string> {
    // Extract IVs and ciphertexts
    const dataKeyIv = encryptedDataKey.slice(0, 12);
    const dataKeyCiphertext = encryptedDataKey.slice(12);
    
    const credentialsIv = encryptedCredentials.slice(0, 12);
    const credentialsCiphertext = encryptedCredentials.slice(12);
    
    // Import master key
    const masterCryptoKey = await crypto.subtle.importKey(
        'raw',
        new TextEncoder().encode(masterKey).slice(0, 32),
        'AES-GCM',
        false,
        ['decrypt']
    );
    
    // Decrypt data key
    const dataKey = await crypto.subtle.decrypt(
        { name: 'AES-GCM', iv: dataKeyIv },
        masterCryptoKey,
        dataKeyCiphertext
    );
    
    // Import data key
    const dataCryptoKey = await crypto.subtle.importKey(
        'raw',
        dataKey,
        'AES-GCM',
        false,
        ['decrypt']
    );
    
    // Decrypt credentials
    const credentials = await crypto.subtle.decrypt(
        { name: 'AES-GCM', iv: credentialsIv },
        dataCryptoKey,
        credentialsCiphertext
    );
    
    return new TextDecoder().decode(credentials);
}

function concatArrays(a: Uint8Array, b: Uint8Array): Uint8Array {
    const result = new Uint8Array(a.length + b.length);
    result.set(a);
    result.set(b, a.length);
    return result;
}
```

---

## Integration Service

**`src/worker/lib/integrations.ts`**

```typescript
import { companyIntegrations, integrationTokenAccessLog } from '../db/schema';
import { encryptCredentials, decryptCredentials } from './encryption';

export type IntegrationType = 'gmail' | 'twilio' | 'telegram';

export async function storeIntegration(
    env: Env,
    companyId: string,
    type: IntegrationType,
    credentials: Record<string, string>,
    accountIdentifier?: string
) {
    const db = getDb(env);
    const credentialsJson = JSON.stringify(credentials);
    
    const { encryptedCredentials, encryptedDataKey } = await encryptCredentials(
        env.ENCRYPTION_MASTER_KEY,
        credentialsJson
    );
    
    await db.insert(companyIntegrations).values({
        companyId,
        integrationType: type,
        encryptedCredentials: Buffer.from(encryptedCredentials),
        dataKeyEncrypted: Buffer.from(encryptedDataKey),
        accountIdentifier,
    }).onConflictDoUpdate({
        target: [companyIntegrations.companyId, companyIntegrations.integrationType],
        set: {
            encryptedCredentials: Buffer.from(encryptedCredentials),
            dataKeyEncrypted: Buffer.from(encryptedDataKey),
            accountIdentifier,
            updatedAt: new Date(),
        },
    });
    
    // Audit log
    await logAccess(db, companyId, type, 'write');
}

export async function getIntegration(
    env: Env,
    companyId: string,
    type: IntegrationType
): Promise<Record<string, string> | null> {
    const db = getDb(env);
    
    const [integration] = await db.select()
        .from(companyIntegrations)
        .where(and(
            eq(companyIntegrations.companyId, companyId),
            eq(companyIntegrations.integrationType, type),
            eq(companyIntegrations.isActive, true)
        ))
        .limit(1);
    
    if (!integration) return null;
    
    // Audit log
    await logAccess(db, companyId, type, 'read');
    
    const credentialsJson = await decryptCredentials(
        env.ENCRYPTION_MASTER_KEY,
        new Uint8Array(integration.encryptedCredentials),
        new Uint8Array(integration.dataKeyEncrypted)
    );
    
    return JSON.parse(credentialsJson);
}
```

---

## Environment Variable

Add master encryption key:

```bash
npx wrangler secret put ENCRYPTION_MASTER_KEY
# Enter a 32+ character random string
```

---

## Acceptance Criteria

- [ ] `company_integrations` table created
- [ ] `integration_token_access_log` table created
- [ ] `encryptCredentials` and `decryptCredentials` functions work
- [ ] `storeIntegration` and `getIntegration` functions implemented
- [ ] Access logged on every read/write
- [ ] Master key loaded from environment

---

## How to Test

```typescript
// Unit test
const creds = { refreshToken: 'secret123', accessToken: 'abc' };

await storeIntegration(env, 'company-uuid', 'gmail', creds, 'user@gmail.com');

const retrieved = await getIntegration(env, 'company-uuid', 'gmail');
expect(retrieved).toEqual(creds);

// Check raw database - should be encrypted
const [row] = await db.select().from(companyIntegrations);
expect(row.encryptedCredentials).not.toContain('secret123');
```

---

## Definition of Done

- [ ] Code reviewed
- [ ] Encryption correctly implemented
- [ ] Unit tests passing
- [ ] Access audit log working
- [ ] PR merged to main
