# T-004: Add Tenant Context to DB Connections

| Field | Value |
|-------|-------|
| **Status** | ðŸ”´ BLOCKED |
| **Round** | 2 |
| **Blocked By** | T-002 âœ… |
| **Effort** | 3-4 hours |
| **Assignee** | _____________ |

---

## Background

T-002 creates Row-Level Security (RLS) policies that filter data based on `app.company_id` session variable. But RLS only works if we **set this variable on every database connection**.

Currently, we create database connections without setting any context:

```typescript
const db = drizzle(env.DATABASE_URL);
// RLS has no company context, so queries might fail or return no data!
```

---

## What This Ticket Achieves

Create a helper function that:
1. Gets a database connection
2. Sets `app.company_id` for RLS filtering
3. Sets `app.is_super_admin` for bypass when needed

All route handlers will use this function instead of raw `drizzle(...)`.

---

## Implementation

### Create Tenant DB Helper

**`src/worker/lib/db-tenant.ts`**

```typescript
import { drizzle } from 'drizzle-orm/neon-http';
import { neon } from '@neondatabase/serverless';
import { sql } from 'drizzle-orm';

/**
 * Get a database connection with tenant context set for RLS
 */
export async function getDbWithTenant(
    env: Env,
    companyId: string,
    isSuperAdmin: boolean = false
) {
    const queryClient = neon(env.DATABASE_URL);
    const db = drizzle(queryClient);
    
    // Set tenant context for this connection
    // Note: Neon serverless is connection-per-query, so we need to set this each time
    await db.execute(sql`SELECT set_config('app.company_id', ${companyId}, false)`);
    await db.execute(sql`SELECT set_config('app.is_super_admin', ${isSuperAdmin.toString()}, false)`);
    
    return db;
}

/**
 * Get database without tenant context (for super admin operations)
 */
export function getDbAdmin(env: Env) {
    const queryClient = neon(env.DATABASE_URL);
    const db = drizzle(queryClient);
    return db;
}
```

### Alternative: Use Transaction

Since Neon's serverless driver opens a new connection for each query, we need to set context in a transaction:

```typescript
export async function withTenantContext<T>(
    env: Env,
    companyId: string,
    isSuperAdmin: boolean,
    fn: (db: DrizzleDB) => Promise<T>
): Promise<T> {
    const queryClient = neon(env.DATABASE_URL);
    const db = drizzle(queryClient);
    
    return db.transaction(async (tx) => {
        // Set context (persists for duration of transaction)
        await tx.execute(sql`SELECT set_config('app.company_id', ${companyId}, true)`);
        await tx.execute(sql`SELECT set_config('app.is_super_admin', ${isSuperAdmin.toString()}, true)`);
        
        return fn(tx);
    });
}

// Usage
const properties = await withTenantContext(env, companyId, false, async (db) => {
    return db.select().from(properties); // Automatically filtered by RLS
});
```

---

## Modify Auth Middleware

**`src/worker/middleware/auth.ts`**

```typescript
import { withTenantContext } from '../lib/db-tenant';

export async function authMiddleware(c: Context, next: Next) {
    // ... verify JWT and get user
    
    const user = await verifyJwt(token, c.env.JWT_SECRET);
    const companyId = user.companyId;
    const isSuperAdmin = user.role === 'super_admin';
    
    // Store context for route handlers
    c.set('user', user);
    c.set('companyId', companyId);
    c.set('isSuperAdmin', isSuperAdmin);
    
    // Create tenant-scoped database getter
    c.set('getTenantDb', async () => {
        return withTenantContext(c.env, companyId, isSuperAdmin, (db) => db);
    });
    
    await next();
}
```

---

## Update Route Handlers

Example route update:

```typescript
// BEFORE
app.get('/api/properties', async (c) => {
    const db = getDb(c.env);
    const companyId = c.get('companyId');
    
    // Manual filtering (error-prone!)
    const props = await db.select()
        .from(properties)
        .where(eq(properties.companyId, companyId));
    
    return c.json(props);
});

// AFTER
app.get('/api/properties', async (c) => {
    const result = await withTenantContext(
        c.env, 
        c.get('companyId'), 
        c.get('isSuperAdmin'),
        async (db) => {
            // RLS automatically filters - no WHERE needed!
            return db.select().from(properties);
        }
    );
    
    return c.json(result);
});
```

---

## Important Notes

1. **Neon serverless creates new connections per query** - We use transactions to maintain context
2. **RLS is defense-in-depth** - Still include WHERE clauses for clarity, but RLS is the safety net
3. **Super admin bypass** - Set `is_super_admin=true` for platform admin routes

---

## Acceptance Criteria

- [ ] `withTenantContext` helper function created
- [ ] Auth middleware sets tenant context
- [ ] At least one route updated to use new pattern
- [ ] Test: Query without setting context returns 0 rows
- [ ] Test: Query with context returns only tenant's data

---

## How to Test

```typescript
// Test RLS enforcement
it('filters by tenant automatically', async () => {
    // Create properties for two companies
    await createProperty({ companyId: 'company-1', name: 'Prop A' });
    await createProperty({ companyId: 'company-2', name: 'Prop B' });
    
    // Query as company-1
    const result = await withTenantContext(env, 'company-1', false, async (db) => {
        return db.select().from(properties);
    });
    
    expect(result).toHaveLength(1);
    expect(result[0].name).toBe('Prop A');
});
```

---

## Definition of Done

- [ ] Code reviewed
- [ ] Helper functions created
- [ ] RLS tested with tenant context
- [ ] PR merged to main
