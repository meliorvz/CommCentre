# T-011: Fix Inbound SMS Tenant Routing

| Field | Value |
|-------|-------|
| **Status** | ðŸ”´ BLOCKED |
| **Round** | 2 |
| **Blocked By** | T-008 âœ… |
| **Effort** | 6-8 hours |
| **Assignee** | _____________ |

---

## Background

When an SMS arrives at one of the platform's Twilio numbers, we need to route it to the correct company. Currently, the routing is **broken for multi-tenant**:

```typescript
// Current (WRONG): Only matches by guest phone number
const stay = await db.select().from(stays)
    .where(eq(stays.guestPhone, fromNumber));
```

**Problem**: The same guest might have stays at different companies! If a guest stayed at Company A last week and Company B this week, their message will be routed to... whichever stay we happen to find first.

---

## Current State (Dangerous)

A security reviewer flagged this as P0:

> "Cross-tenant message leakage via inbound routing: Inbound SMS is matched by `From` number only. If the same guest phones two different businesses using this system, messages can be misdirected."

---

## What This Ticket Achieves

Route inbound SMS based on the **To** number, which maps to a specific company's phone number in `company_phone_numbers` table.

**Correct flow:**
1. Twilio sends webhook with `To` = company's Twilio number
2. Lookup `company_phone_numbers` table to find which company owns that number
3. Filter stays by BOTH `guest_phone` AND `company_id`
4. Route to correct thread

---

## Implementation

### `src/worker/routes/webhooks/twilio.ts`

```typescript
import { companyPhoneNumbers } from '../db/schema';

async function handleInboundSms(c: Context) {
    const body = c.get('twilioBody');
    const fromNumber = body.From;    // Guest's phone
    const toNumber = body.To;        // Our Twilio number
    const messageBody = body.Body;
    
    const db = getDb(c.env);
    
    // Step 1: Find which company owns the To number
    const [phoneRecord] = await db.select()
        .from(companyPhoneNumbers)
        .where(eq(companyPhoneNumbers.phoneNumber, toNumber))
        .limit(1);
    
    if (!phoneRecord) {
        console.error(`Unknown To number: ${toNumber}`);
        // Log to comms_events with company_id = null
        await logCommsEvent(c.env, {
            companyId: null,
            channel: 'sms',
            direction: 'inbound',
            fromAddr: fromNumber,
            toAddr: toNumber,
            body: messageBody,
            status: 'rejected',
            errorMessage: 'Unknown destination number',
        });
        return c.text('Number not found', 400);
    }
    
    const companyId = phoneRecord.companyId;
    
    // Step 2: Find the guest's stay for THIS COMPANY
    const [stay] = await db.select()
        .from(stays)
        .innerJoin(properties, eq(stays.propertyId, properties.id))
        .where(and(
            eq(stays.guestPhone, fromNumber),
            eq(properties.companyId, companyId),
            // Optionally: filter to active stays
            gte(stays.checkoutDate, new Date())
        ))
        .orderBy(desc(stays.checkinDate))
        .limit(1);
    
    if (!stay) {
        console.warn(`No active stay found for ${fromNumber} at company ${companyId}`);
        // Escalate to company owner - unknown guest
        await escalateUnknownGuest(c.env, companyId, fromNumber, messageBody);
        return c.text('OK - escalated');
    }
    
    // Step 3: Route to thread
    const threadId = await getOrCreateThread(c.env, stay.id, companyId);
    
    // ... rest of message processing
}

async function escalateUnknownGuest(
    env: Env, 
    companyId: string, 
    guestPhone: string, 
    message: string
) {
    // Notify company via Telegram or email
    const telegram = await getIntegration(env, companyId, 'telegram');
    if (telegram) {
        await sendTelegram(env, telegram.chatId, 
            `ðŸ“± Unknown guest message:\nFrom: ${guestPhone}\n"${message}"`
        );
    }
}
```

---

## company_phone_numbers Table

This table should already exist. Verify the schema:

```sql
CREATE TABLE IF NOT EXISTS company_phone_numbers (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    company_id UUID NOT NULL REFERENCES companies(id) ON DELETE CASCADE,
    phone_number TEXT NOT NULL UNIQUE,
    friendly_name TEXT,
    twilio_sid TEXT,
    capabilities JSONB DEFAULT '{"sms": true, "voice": true}',
    is_primary BOOLEAN DEFAULT false,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_phone_numbers_number ON company_phone_numbers(phone_number);
```

---

## Edge Cases

1. **Unknown To number** â†’ Reject with 400, log error
2. **Unknown guest** â†’ Escalate to company owner
3. **Multiple stays for same guest/company** â†’ Use most recent active stay
4. **Guest with expired stay** â†’ Still route to their last thread (for post-checkout questions)

---

## Acceptance Criteria

- [ ] Inbound SMS extracts `To` number from Twilio webhook
- [ ] Lookup company from `company_phone_numbers` table
- [ ] Reject with 400 if To number not registered
- [ ] Stay lookup filtered by company_id
- [ ] Unknown guest messages are escalated, not dropped
- [ ] Test: Same guest with stays at 2 companies routes correctly

---

## How to Test

1. Set up two companies with different Twilio numbers
2. Create a stay for "Guest A" at Company 1
3. Create a stay for "Guest A" at Company 2 (same phone number)
4. Send SMS to Company 1's number from Guest A
5. Verify message goes to Company 1's thread
6. Send SMS to Company 2's number from Guest A
7. Verify message goes to Company 2's thread (separate)

---

## Definition of Done

- [ ] Code reviewed
- [ ] Integration tests for multi-tenant routing
- [ ] Unknown guest escalation working
- [ ] PR merged to main
