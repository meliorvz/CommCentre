# T-024: Migrate Gmail to Per-Tenant Tokens

| Field | Value |
|-------|-------|
| **Status** | ðŸ”´ BLOCKED |
| **Round** | 2 |
| **Blocked By** | T-023 âœ… |
| **Effort** | 8-10 hours |
| **Assignee** | _____________ |

---

## Background

Currently, Gmail integration uses **global environment variables**:

```typescript
const refreshToken = env.GMAIL_REFRESH_TOKEN; // Shared by ALL companies!
const accessToken = env.GMAIL_ACCESS_TOKEN;
```

This means **all companies share the same Gmail account** for sending emails. This is a critical P0 issue.

---

## What This Ticket Achieves

1. Store Gmail OAuth tokens per-company using T-023's encrypted storage
2. Update Gmail operations to load tokens from database
3. Handle token refresh and storage
4. Remove global Gmail environment variables for tenant operations

---

## Implementation

### Update OAuth Flow

**`src/worker/routes/oauth.ts`**

```typescript
import { storeIntegration, getIntegration } from '../lib/integrations';

// OAuth callback after user grants access
app.get('/api/oauth/gmail/callback', async (c) => {
    const code = c.req.query('code');
    const state = c.req.query('state');
    
    // Verify state and get company ID
    const { companyId, userId } = await verifyOAuthState(c.env, state);
    
    // Exchange code for tokens
    const tokenResponse = await fetch('https://oauth2.googleapis.com/token', {
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
        body: new URLSearchParams({
            code,
            client_id: c.env.GOOGLE_CLIENT_ID,
            client_secret: c.env.GOOGLE_CLIENT_SECRET,
            redirect_uri: `${c.env.WORKER_BASE_URL}/api/oauth/gmail/callback`,
            grant_type: 'authorization_code',
        }),
    });
    
    const tokens = await tokenResponse.json();
    
    // Get user's email address for display
    const userInfo = await fetch('https://www.googleapis.com/oauth2/v2/userinfo', {
        headers: { Authorization: `Bearer ${tokens.access_token}` },
    });
    const { email } = await userInfo.json();
    
    // Store tokens encrypted per-company (T-023)
    await storeIntegration(c.env, companyId, 'gmail', {
        refreshToken: tokens.refresh_token,
        accessToken: tokens.access_token,
        expiresAt: Date.now() + (tokens.expires_in * 1000),
    }, email);
    
    // Audit log
    await logAudit(c.env, {
        companyId,
        actorUserId: userId,
        action: 'integration.connected',
        resourceType: 'integration',
        resourceId: 'gmail',
        afterState: { email },
    });
    
    // Redirect back to settings
    return c.redirect('/settings/integrations?gmail=connected');
});
```

---

### Update Gmail Client

**`src/worker/lib/gmail.ts`**

```typescript
import { getIntegration, storeIntegration } from './integrations';

interface GmailTokens {
    refreshToken: string;
    accessToken: string;
    expiresAt: number;
}

/**
 * Get Gmail client for a specific company
 */
export async function getGmailClient(env: Env, companyId: string): Promise<GmailClient | null> {
    const tokens = await getIntegration(env, companyId, 'gmail') as GmailTokens;
    
    if (!tokens) {
        return null; // Company hasn't connected Gmail
    }
    
    // Check if access token is expired (with 5 min buffer)
    if (tokens.expiresAt < Date.now() + 5 * 60 * 1000) {
        // Refresh the token
        const newTokens = await refreshAccessToken(env, companyId, tokens.refreshToken);
        return createGmailClient(newTokens.accessToken);
    }
    
    return createGmailClient(tokens.accessToken);
}

async function refreshAccessToken(
    env: Env, 
    companyId: string, 
    refreshToken: string
): Promise<GmailTokens> {
    const response = await fetch('https://oauth2.googleapis.com/token', {
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
        body: new URLSearchParams({
            refresh_token: refreshToken,
            client_id: env.GOOGLE_CLIENT_ID,
            client_secret: env.GOOGLE_CLIENT_SECRET,
            grant_type: 'refresh_token',
        }),
    });
    
    const data = await response.json();
    
    const newTokens: GmailTokens = {
        refreshToken: refreshToken, // Keep original refresh token
        accessToken: data.access_token,
        expiresAt: Date.now() + (data.expires_in * 1000),
    };
    
    // Store updated tokens
    await storeIntegration(env, companyId, 'gmail', newTokens);
    
    return newTokens;
}

/**
 * Send email for a specific company
 */
export async function sendEmail(env: Env, params: SendEmailParams): Promise<SendResult> {
    const { companyId, to, subject, body, from } = params;
    
    const client = await getGmailClient(env, companyId);
    
    if (!client) {
        throw new Error(`Gmail not connected for company ${companyId}`);
    }
    
    const result = await client.messages.send({
        userId: 'me',
        requestBody: {
            raw: encodeEmail({ to, subject, body, from }),
        },
    });
    
    return { messageId: result.data.id };
}
```

---

### Update Email Handler

**`src/worker/email-handler.ts`**

```typescript
// When processing inbound email, check company's Gmail connection
async function processInboundEmail(env: Env, message: ForwardableEmailMessage) {
    const companyId = await lookupCompanyFromEmail(message.to);
    
    // Get company's Gmail for sending replies
    const gmailClient = await getGmailClient(env, companyId);
    
    if (!gmailClient) {
        console.warn(`Company ${companyId} hasn't connected Gmail`);
        // Store message but can't auto-reply
        await storeMessage(env, companyId, message);
        await escalate(env, companyId, 'Gmail not connected - cannot send replies');
        return;
    }
    
    // ... process and potentially reply
}
```

---

## Migration Strategy

1. Keep global `GMAIL_*` env vars for backward compatibility during transition
2. Check for per-company tokens first, fall back to global if not found
3. Document that global tokens are deprecated
4. Remove global tokens after all companies have connected their own

```typescript
async function getGmailClient(env: Env, companyId: string): Promise<GmailClient | null> {
    // Try per-company tokens first
    const companyTokens = await getIntegration(env, companyId, 'gmail');
    if (companyTokens) {
        return createGmailClient(companyTokens.accessToken);
    }
    
    // Fallback to global (deprecated)
    if (env.GMAIL_REFRESH_TOKEN) {
        console.warn(`Company ${companyId} using deprecated global Gmail tokens`);
        return createGmailClient(await getGlobalAccessToken(env));
    }
    
    return null;
}
```

---

## Acceptance Criteria

- [ ] OAuth callback stores tokens in `company_integrations`
- [ ] Gmail operations load tokens per-company
- [ ] Token refresh works and updates storage
- [ ] Each company sees only their own email
- [ ] Disconnect removes tokens from database
- [ ] Migration path from global tokens

---

## How to Test

1. Connect Gmail for Company A (different email than global)
2. Connect Gmail for Company B (another different email)
3. Send email as Company A â†’ verify it comes from Company A's email
4. Send email as Company B â†’ verify it comes from Company B's email
5. Check that Gmail operations work after token expiry (refresh flow)

---

## Definition of Done

- [ ] Code reviewed
- [ ] OAuth flow stores per-company tokens
- [ ] Email sending uses per-company tokens
- [ ] Token refresh working
- [ ] Integration tests passing
- [ ] PR merged to main
