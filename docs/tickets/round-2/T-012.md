# T-012: Fix Inbound Email Tenant Routing

| Field | Value |
|-------|-------|
| **Status** | ðŸ”´ BLOCKED |
| **Round** | 2 |
| **Blocked By** | T-009 âœ… |
| **Effort** | 6-8 hours |
| **Assignee** | _____________ |

---

## Background

Same problem as T-011 but for email. When an email arrives, we need to route it to the correct company based on the **To** address.

Currently:
```typescript
// WRONG: Only matches by guest email
const stay = await db.select().from(stays)
    .where(eq(stays.guestEmail, fromEmail));
```

---

## What This Ticket Achieves

1. Create `company_email_addresses` table to map email addresses to companies
2. Route inbound emails based on the To address
3. Add email loop protection (prevent auto-reply loops)

---

## Database Table

```sql
CREATE TABLE company_email_addresses (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    company_id UUID NOT NULL REFERENCES companies(id) ON DELETE CASCADE,
    email_address TEXT NOT NULL UNIQUE,
    purpose TEXT DEFAULT 'inbox' CHECK (purpose IN ('inbox', 'noreply', 'support')),
    is_primary BOOLEAN DEFAULT false,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_email_addresses_email ON company_email_addresses(email_address);
```

---

## Implementation

### `src/worker/email-handler.ts`

```typescript
import { companyEmailAddresses } from '../db/schema';

export default {
    async email(message: ForwardableEmailMessage, env: Env) {
        const fromEmail = message.from;
        const toEmail = message.to;
        
        const db = getDb(env);
        
        // Step 1: Find which company owns the To address
        const [emailRecord] = await db.select()
            .from(companyEmailAddresses)
            .where(eq(companyEmailAddresses.emailAddress, toEmail))
            .limit(1);
        
        if (!emailRecord) {
            console.error(`Unknown To email: ${toEmail}`);
            // Silently drop - don't bounce (avoid backscatter)
            return;
        }
        
        const companyId = emailRecord.companyId;
        
        // Step 2: Check for email loops
        if (await isAutoReply(message)) {
            console.log(`Dropping auto-reply from ${fromEmail}`);
            await logCommsEvent(env, {
                companyId,
                channel: 'email',
                direction: 'inbound',
                fromAddr: fromEmail,
                toAddr: toEmail,
                status: 'dropped',
                errorMessage: 'Auto-reply detected',
            });
            return;
        }
        
        // Step 3: Find guest's stay for THIS COMPANY
        const [stay] = await db.select()
            .from(stays)
            .innerJoin(properties, eq(stays.propertyId, properties.id))
            .where(and(
                eq(stays.guestEmail, fromEmail),
                eq(properties.companyId, companyId),
            ))
            .orderBy(desc(stays.checkinDate))
            .limit(1);
        
        if (!stay) {
            // Escalate - unknown guest email
            await escalateUnknownGuestEmail(env, companyId, message);
            return;
        }
        
        // Step 4: Route to thread
        const threadId = await getOrCreateThread(env, stay.id, companyId);
        
        // ... process message
    }
}

async function isAutoReply(message: ForwardableEmailMessage): Promise<boolean> {
    const headers = message.headers;
    
    // Check common auto-reply indicators
    const autoSubmitted = headers.get('Auto-Submitted');
    if (autoSubmitted && autoSubmitted !== 'no') {
        return true;
    }
    
    const precedence = headers.get('Precedence');
    if (precedence && ['bulk', 'junk', 'list', 'auto_reply'].includes(precedence.toLowerCase())) {
        return true;
    }
    
    const xAutoReply = headers.get('X-Auto-Response-Suppress');
    if (xAutoReply) {
        return true;
    }
    
    // Check for common auto-reply subjects
    const subject = headers.get('Subject') || '';
    const autoReplyPatterns = [
        /^auto:/i,
        /^automatic reply/i,
        /^out of office/i,
        /^vacation/i,
        /^away from/i,
    ];
    
    return autoReplyPatterns.some(pattern => pattern.test(subject));
}
```

---

## Loop Protection Details

Email loops can happen when:
1. Our system sends an auto-reply
2. The recipient's OOO sends a reply back
3. Our system sends another auto-reply
4. Infinite loop!

**Detection methods:**
- `Auto-Submitted` header (RFC 3834)
- `Precedence: bulk/junk/list` header
- `X-Auto-Response-Suppress` header (Microsoft)
- Subject line patterns ("Out of Office", etc.)
- From address patterns (noreply@, auto@, etc.)

---

## Acceptance Criteria

- [ ] `company_email_addresses` table created
- [ ] Inbound email extracts To address
- [ ] Lookup company from email_addresses table
- [ ] Unknown To addresses silently dropped (no bounce)
- [ ] Auto-reply emails detected and dropped
- [ ] Stay lookup filtered by company_id
- [ ] Unknown guest emails escalated

---

## How to Test

1. Set up two companies with different email addresses
2. Create stays for same guest at both companies
3. Send email to Company 1's address
4. Verify it routes to Company 1's thread
5. Send email to Company 2's address
6. Verify it routes to Company 2's thread

### Loop protection test:
```bash
# Simulate auto-reply email
curl -X POST /api/webhooks/email/inbound \
  -H "Auto-Submitted: auto-replied" \
  -d '{"from":"guest@example.com", "to":"inbox@company.com", "subject":"Re: Your stay"}'
# Should be dropped
```

---

## Definition of Done

- [ ] Code reviewed
- [ ] Multi-tenant routing tested
- [ ] Loop protection tested
- [ ] PR merged to main
