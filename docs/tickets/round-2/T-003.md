# T-003: Make ConfigDO Per-Tenant

| Field | Value |
|-------|-------|
| **Status** | ðŸ”´ BLOCKED |
| **Round** | 2 |
| **Blocked By** | T-001 âœ… |
| **Effort** | 6-8 hours |
| **Assignee** | _____________ |

---

## Background

This platform uses **Cloudflare Durable Objects** for stateful operations. `ConfigDO` holds the AI configuration (prompts, settings, etc.) in memory for fast access.

Currently, **ConfigDO is a global singleton** shared by ALL companies:

```typescript
const configId = env.CONFIG_DO.idFromName('global'); // Everyone uses this!
```

This means all companies share the same AI prompts and settings.

---

## What This Ticket Achieves

Change ConfigDO to be **per-company** - each company gets their own instance:

```typescript
const configId = env.CONFIG_DO.idFromName(companyId); // Isolated per tenant
```

---

## Files to Modify

### `src/do/ConfigDO.ts`

Update to accept companyId and load from database:

```typescript
export class ConfigDO implements DurableObject {
    private companyId: string = '';
    private config: CompanyConfig | null = null;
    
    constructor(private state: DurableObjectState, private env: Env) {}
    
    async fetch(request: Request): Promise<Response> {
        const url = new URL(request.url);
        const companyId = url.searchParams.get('companyId');
        
        if (companyId && companyId !== this.companyId) {
            this.companyId = companyId;
            this.config = null; // Force reload
        }
        
        switch (url.pathname) {
            case '/config':
                return Response.json(await this.getConfig());
            case '/reload':
                this.config = null;
                return Response.json({ reloaded: true });
            default:
                return new Response('Not found', { status: 404 });
        }
    }
    
    private async getConfig(): Promise<CompanyConfig> {
        if (this.config) return this.config;
        
        // Load from database using T-001 tables
        const db = getDb(this.env);
        
        const [profile] = await db.select()
            .from(companyProfile)
            .where(eq(companyProfile.companyId, this.companyId))
            .limit(1);
        
        const [aiConfig] = await db.select()
            .from(companyAiConfig)
            .where(eq(companyAiConfig.companyId, this.companyId))
            .limit(1);
        
        const [publishedPrompt] = await db.select()
            .from(companyPrompts)
            .where(and(
                eq(companyPrompts.companyId, this.companyId),
                eq(companyPrompts.isPublished, true)
            ))
            .limit(1);
        
        const knowledgeItems = await db.select()
            .from(knowledgeItems)
            .where(eq(knowledgeItems.companyId, this.companyId));
        
        this.config = {
            profile: profile || getDefaultProfile(),
            aiConfig: aiConfig || getDefaultAiConfig(),
            prompt: publishedPrompt?.content || getDefaultPrompt(),
            knowledge: knowledgeItems,
        };
        
        return this.config;
    }
}
```

### `src/do/ThreadDO.ts`

Pass companyId when getting ConfigDO:

```typescript
export class ThreadDO implements DurableObject {
    private companyId: string = '';
    
    private async getConfig(): Promise<CompanyConfig> {
        // OLD: Global config
        // const id = this.env.CONFIG_DO.idFromName('global');
        
        // NEW: Per-company config
        const id = this.env.CONFIG_DO.idFromName(this.companyId);
        const stub = this.env.CONFIG_DO.get(id);
        
        const response = await stub.fetch(
            `https://config/config?companyId=${this.companyId}`
        );
        return response.json();
    }
}
```

### `src/do/SchedulerDO.ts`

Same pattern - pass companyId:

```typescript
export class SchedulerDO implements DurableObject {
    private async getConfigForCompany(companyId: string): Promise<CompanyConfig> {
        const id = this.env.CONFIG_DO.idFromName(companyId);
        const stub = this.env.CONFIG_DO.get(id);
        
        const response = await stub.fetch(
            `https://config/config?companyId=${companyId}`
        );
        return response.json();
    }
}
```

### `src/worker/index.ts`

Update any routes that access ConfigDO directly.

---

## Key Design Decisions

1. **Durable Object ID = companyId** - Each company gets a separate DO instance
2. **Lazy loading** - Config loaded from DB on first request, then cached
3. **Cache invalidation** - Call `/reload` when settings change
4. **Default values** - If no config exists, return sensible defaults

---

## Acceptance Criteria

- [ ] ConfigDO uses companyId as its identifier
- [ ] ConfigDO loads config from database (T-001 tables)
- [ ] ThreadDO passes companyId when getting ConfigDO
- [ ] SchedulerDO passes companyId when getting ConfigDO
- [ ] Test: Create 2 companies with different prompts, verify isolation
- [ ] Cache invalidation works

---

## How to Test

1. Create two companies with different assistant names
2. Send an inbound message to each company's number
3. Verify the AI responds with the correct assistant name for each

```sql
-- Set up test data
INSERT INTO company_profile (company_id, assistant_name) VALUES 
    ('company-1-uuid', 'Alice'),
    ('company-2-uuid', 'Bob');
```

---

## Definition of Done

- [ ] Code reviewed
- [ ] Integration tests passing
- [ ] Multi-tenant isolation verified
- [ ] PR merged to main
